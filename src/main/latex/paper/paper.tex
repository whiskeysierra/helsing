\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{csquotes}
\usepackage[ngerman]{babel}
\usepackage{biblatex}
\usepackage{float}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{subfigure}
\usepackage{array}
\usepackage[table]{xcolor}
\usepackage[format=plain,labelfont=bf,up]{caption}
\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{-1} 
\usepackage{hyperref}
\usepackage{nameref}
\usepackage{minted}
\usemintedstyle{friendly}
\bibliography{paper}
\title{Tenzing \\ Eine SQL-Implementierung auf Basis des MapReduce-Frameworks}
\author{Willi Schönborn}
\date{\today}
\definecolor{cell}{HTML}{1BB2E0}
\definecolor{cell-odd}{HTML}{7EE01B}
\begin{document}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{beuth.eps}
\maketitle
\end{figure}

\newpage

\tableofcontents

\newpage

\section{Einleitung}
Als Teil der Lehrveranstaltung \textit{Programmierung - Fortgeschrittene Konzepte} im Wintersemester 2011/2012 an der \textit{Beuth Hochschule für Technik Berlin} sollte im Rahmen einer Semesterarbeit ein wissenschaftliches Paper ausgewählt, untersucht und bewertet werden. Das Ziel dieses Dokumentes ist es die Ergebnisse dieser Semesterarbeit zusammenzufassen.

\section{Kurzbeschreibung}
Ausgewählt wurde das Google-Paper \textit{Tenzing A SQL Implementation On The MapReduce Framework} \cite{TENZING}. Erschienen ist das Paper als Teil der Proceedings zur 37th VLDB, der \textit{International Conference on Very Large Data Bases} im September 2011. Die Autoren sind die Google-Mitarbeiter Biswapesh Chattopadhyay, Liang Lin, Weiran Liu, Sagar Mittal, Prathyusha Aragonda, Vera Lychagina, Younghee Kwon und Michael Wong.
Tenzing ist eine SQL92-kompatible Implementierung auf Basis des Google-eigenen MapReduce-Frameworks \cite{MAPREDUCE}. Die beiden zugrundeliegenden Technologien werden in den Kapiteln \textit{\nameref{sql}} und \textit{\nameref{mapreduce}}, im Kontext des Hauptthemas, näher erläutert.

\newpage

\section{SQL}
\label{sql}
SQL steht für \textit{Structured Query Language} und ist eine standardisierte, mengenorientierte und deklarative Datenbanksprache die in vielen Datenbank-Management-Systemen zum Einsatz kommt. SQL bietet Möglichkeiten zur Definition, Manipulation und zur Abfrage von Daten an. Für die Definition und die Manipulation existieren zwei Sprachen die jeweils eine Teilmenge von SQL bilden: die \textit{Data Definition Language} (DDL) und die \textit{Data Manipulation Language} (DML). Beide werden zwar zum Teil von Tenzing unterstützt, der eigentliche Schwerpunkt liegt aber klar auf der Abfrage von Daten. Aus diesem Grund wird in den folgenden Kapiteln verstärkt auf den Abfrage-Teil von SQL eingegangen.

\subsection{Syntax und Sprachelemente}
Listing \ref{sql-syntax} zeigt die wichtigsten Bestandteile eines SQL-Queries in Form einer Form einer sehr einfachen Grammatik. Alle abgebildeten Teile der SQL-Query-Syntax werden in den folgenden Unterkapiteln kurz anhand eines Beispiels und einer visuellen Darstellung erklärt.

\begin{listing}[H]
\begin{minted}{sql}
SELECT field+
FROM table+
[[[LEFT|RIGHT] [INNER|OUTER]] JOIN table [ON condition]]+
[WHERE condition [(AND|OR) condition]+]
[GROUP BY attribute+;
\end{minted}
\caption{SQL Query-Syntax}
\label{sql-syntax}
\end{listing}

\subsection{Referenztabellen und Beispieldaten}
Die folgenden Abbildungen stellen die Struktur zweier Datenbank-Tabellen sowie entsprechende Beispieldaten dar. Beide Tabellen werden in den folgenden Abschnitten als Grundlage genutzt um einzelne Merkmale und Eigenschaften von SQL anhand von konkreten Beispielen zu erklären.

\begin{table}[H]
\centering
\subfigure[City-Tabelle]{
  \begin{tabular}{| l | l | l | l |}
    \hline
    id & name & population & country\protect{\textunderscore}id \\ \hline
    \hline
   1 & Berlin & 3471756 & 1 \\ \hline
   2 & München & 1353186 & 1 \\ \hline
   3 & London & 7825200 & 2 \\ \hline
   4 & Paris & 2211297 & 3 \\ \hline
   5 & Edinburgh & 486120 & 2 \\ \hline
   6 & New York City & 8175133 & 4 \\ \hline
   7 & Los Angeles & 3831868 & 4 \\ \hline
   8 & Lyon & 474946 & 3 \\ \hline
   9 & Stockholm & 855361 & NULL \\ \hline
  \end{tabular}
}
\subfigure[Country-Tabelle]{
  \begin{tabular}{| l | l | l |}
    \hline
    id & name & country\protect{\textunderscore}code \\ \hline
    \hline
    1 & Deutschland & DE \\ \hline
    2 & United Kingdom & UK \\ \hline
    3 & France & FR \\ \hline
    4 & United States & US \\ \hline
    5 & Japan & JP \\ \hline
  \end{tabular}
}
\caption{Beispiel-Tabellen}
\label{example}
\end{table}

\newpage
\subsection{Projektion}
Bei der Projektion werden einzelne Spalten einer Tabelle selektiert. Dazu werden in der Projektionsklausel, zu erkennen am Schlüsselwort \texttt{SELECT}, einfach, wie in Listing \ref{lst:projection} dargestellt, die gewünschten Spaltennamen aufgezählt.

\begin{listing}[H]
\begin{minted}{sql}
SELECT id, name FROM City;
\end{minted}
\caption{SQL-Query für eine Projektion}
\label{lst:projection}
\end{listing}

\begin{minipage}{\textwidth}
\begin{minipage}[b]{0.49\textwidth}
\begin{figure}[H]
\centering
  \begin{tabular}{| c | c | c | c |}
    \hline
     \cellcolor{cell} & \cellcolor{cell} & & \\ \hline
     \cellcolor{cell} & \cellcolor{cell} & & \\ \hline
     \cellcolor{cell} & \cellcolor{cell} & & \\ \hline
     \cellcolor{cell} & \cellcolor{cell} & & \\ \hline
     \cellcolor{cell} & \cellcolor{cell} & & \\ \hline
     \cellcolor{cell} & \cellcolor{cell} & & \\ \hline
     \cellcolor{cell} & \cellcolor{cell} & & \\ \hline
     \cellcolor{cell} & \cellcolor{cell} & & \\ \hline
     \cellcolor{cell} & \cellcolor{cell} & & \\ \hline
  \end{tabular}
\caption{Schema einer Projektion}
\label{fig:projection}
\end{figure}
\end{minipage}
\hfill
\begin{minipage}[b]{0.49\textwidth}
\begin{table}[H]
\centering
  \begin{tabular}{| l | l | l | l |}
    \hline
    id & name \\ \hline
    \hline
   1 & Berlin \\ \hline
   2 & München \\ \hline
   3 & London \\ \hline
   4 & Paris \\ \hline
   5 & Edinburgh \\ \hline
   6 & New York City \\ \hline
   7 & Los Angeles \\ \hline
   8 & Lyon \\ \hline
   9 & Stockholm \\ \hline
  \end{tabular}
\caption{Ergebnis einer Projektion}
\label{tab:projection}
\end{table}
\end{minipage}
\end{minipage}

\subsection{Selektion}
Eine Selektion arbeitet im Gegensatz zur Projektion nicht auf den Spalten, sondern auf den Zeilen. Weil die Spalten die Struktur einer Tabelle definieren und die Zeilen die eigentlichen Daten enthalten gibt es in der Regel eine Vielzahl mehr Zeilen als Spalten. Weiterhin sind Zeilen nicht zwangsläufig mit einen eindeutigen Bezeichner versehen wie es für Spalten der Fall ist. Aus diesem Grund reicht es meist nicht aus die gewünschten Zeilen aufzuzählen wie es bei der Projektion der Fall ist. Stattdessen kommen Bedingungen in Form einer \texttt{WHERE}-Klausel zum Einsatz. Tenzing unterstützt alle gängigen Prädikate wie \texttt{AND}. \texttt{OR}. \texttt{LIKE} und \texttt{BETWEEN}.

\begin{listing}[H]
\begin{minted}{sql}
SELECT * FROM City WHERE population > 2500000;
\end{minted}
\caption{SQL-Query für eine Selektion}
\label{lst:selection}
\end{listing}

\begin{minipage}{\textwidth}
\begin{minipage}[b]{0.49\textwidth}
\begin{figure}[H]
\centering
  \begin{tabular}{| c | c | c | c |}
    \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} \\ \hline
     & &  & \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} \\ \hline
     & &  & \\ \hline
     & &  & \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} \\ \hline
     & &  & \\ \hline
     & &  & \\ \hline
  \end{tabular}
\caption{Schema einer Selektion}
\label{fig:selection}
\end{figure}
\end{minipage}
\hfill
\begin{minipage}[b]{0.49\textwidth}
\begin{table}[H]
\centering
  \begin{tabular}{| l | l | l | l |}
    \hline
    id & name & population & country\protect{\textunderscore}id \\ \hline
    \hline
   1 & Berlin & 3471756 & 1 \\ \hline
   3 & London & 7825200 & 2 \\ \hline
   6 & New York City & 8175133 & 4 \\ \hline
   7 & Los Angeles & 3831868 & 4 \\ \hline
  \end{tabular}
\caption{Ergebnis einer Selektion}
\label{tab:selection}
\end{table}
\end{minipage}
\end{minipage}

\newpage
\subsection{Gruppierung und Aggregatfunktionen}
SQL im Allgemeinen und Tenzing im Speziellen haben einen starken Fokus auf die Datenanalyse. Dazu zählen vorallem die statistische Analyse von Datenbeständen. SQL bietet für diesen Fall sogenannte Aggregatfunktionen in Kombination mit der \texttt{GROUP BY}-Klausel. Mithilfe einer Aggregatfunktionen wird für eine Gruppe ein einzelner Wert berechnet. Die Bildung dieser Gruppen wird durch die Angabe der \texttt{GROUP BY}-Klausel geregelt. Wird keine solche Klausel angegeben bezieht sich die Aggregatfunktion auf die gesamte Menge aller ausgewählten Tupel. Tenzing unterstützt neben den klassischen Aggregatfunktionen wie \texttt{SUM}, \texttt{COUNT}, \texttt{MIN}, \texttt{MAX} und \texttt{COUNT DISTINCT} wichtige statistische Aggregatfunktionen wie \texttt{CORR}, \texttt{COVAR} und \texttt{STDDEV} für den Korrelationskoeffizienten, die empirische Kovarianz respektive die Standardabweichung.

\begin{listing}[H]
\begin{minted}{sql}
SELECT country_id, AVG(population) FROM City 
GROUP BY country_id 
ORDER BY AVG(population) DESC;
\end{minted}
\caption{SQL-Query für eine Gruppierung mit Aggregatfunktion}
\label{lst:group}
\end{listing}

Die Ergebnistabelle \ref{tab:group} zeigt das Ergebnis des Queries aus Listing \ref{lst:group}. Berechnet wurde die durchschnittliche Bevölkerungsstärke pro Land.

\begin{table}[H]
\centering
  \begin{tabular}{| l | l | l | l |}
    \hline
     country\protect{\textunderscore}id & AVG(population) \\ \hline
    \hline
    4 & 6003500 \\ \hline
    2 & 4155660 \\ \hline
    1 & 2412471 \\ \hline
    3 & 1343121 \\ \hline
  \end{tabular}
\caption{Ergebnis einer Gruppierung mit Aggregatfunktion}
\label{tab:group}
\end{table}

\newpage
\subsection{Mengenoperationen}
SQL bietet Unterstützung für die drei wichtigsten Mengenoperationen: die Vereinigung, der Durchschnitt und die Differenz. Die Bedingung für die beteiligten Mengen ist eine kompatible Projektion. Das heißt die entsprechenden Operationen können nur ausgeführt werden wenn die gleiche Anzahl Spalten selekiert wurden. Mathematisch betrachtet müssen die Tupel aller beteiligten Mengen die gleiche Länge haben. Tenzing unterstützt die Vereinigung und die Differenz von Megen in Form der Schlüsselwörter \texttt{UNION} und \texttt{MINUS}.

\begin{listing}[H]
\begin{minted}{sql}
SELECT id, name FROM City UNION SELECT id, name FROM Country;
\end{minted}
\caption{SQL-Query für eine Vereinigung}
\label{lst:union}
\end{listing}

Abbildung \ref{fig:union} und Tabelle \ref{tab:union} zeigen das Ergebnis des Union-Queries aus Listing \ref{lst:union} über die Beispieltabellen \texttt{City} und \texttt{Country}.

\begin{minipage}{\textwidth}
\begin{minipage}[b]{0.49\textwidth}
\begin{figure}[H]
\centering
\subfigure[]{
  \begin{tabular}{| c | c | c | c | c |}
    \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
  \end{tabular}
}
\subfigure[]{
  \begin{tabular}{| c | c | c | c | c |}
    \hline
    \cellcolor{cell-odd} & \cellcolor{cell-odd} & \cellcolor{cell-odd} &  \cellcolor{cell-odd} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} & \cellcolor{cell-odd} & \cellcolor{cell-odd} &  \cellcolor{cell-odd} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} & \cellcolor{cell-odd} & \cellcolor{cell-odd} &  \cellcolor{cell-odd} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} & \cellcolor{cell-odd} & \cellcolor{cell-odd} &  \cellcolor{cell-odd} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} & \cellcolor{cell-odd} & \cellcolor{cell-odd} &  \cellcolor{cell-odd} & \cellcolor{cell-odd} \\ \hline
  \end{tabular}
}
\end{figure}
\begin{figure}[H]
\centering
  \begin{tabular}{| c | c | c | c | c |}
    \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell} & \cellcolor{cell} & \cellcolor{cell} &  \cellcolor{cell} & \cellcolor{cell} \\ \hline
    \cellcolor{cell-odd} & \cellcolor{cell-odd} & \cellcolor{cell-odd} &  \cellcolor{cell-odd} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} & \cellcolor{cell-odd} & \cellcolor{cell-odd} &  \cellcolor{cell-odd} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} & \cellcolor{cell-odd} & \cellcolor{cell-odd} &  \cellcolor{cell-odd} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} & \cellcolor{cell-odd} & \cellcolor{cell-odd} &  \cellcolor{cell-odd} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} & \cellcolor{cell-odd} & \cellcolor{cell-odd} &  \cellcolor{cell-odd} & \cellcolor{cell-odd} \\ \hline
  \end{tabular}
\caption{Schema einer Vereinigung}
\label{fig:union}
\end{figure}
\end{minipage}
\hfill
\begin{minipage}[b]{0.49\textwidth}
\begin{table}[H]
\centering
  \begin{tabular}{| l | l | l | l |}
    \hline
    id & name\\ \hline
    \hline
   1 & Berlin \\ \hline
   2 & München \\ \hline
   3 & London \\ \hline
   4 & Paris \\ \hline
   5 & Edinburgh \\ \hline
   6 & New York City \\ \hline
   7 & Los Angeles \\ \hline
   8 & Lyon \\ \hline
   9 & Stockholm  \\ \hline
    1 & Deutschland \\ \hline
    2 & United Kingdom \\ \hline
    3 & France \\ \hline
    4 & United States \\ \hline
    5 & Japan \\ \hline
  \end{tabular}
\caption{Ergebnis einer Vereinigung}
\label{tab:union}
\end{table}
\end{minipage}
\end{minipage}

\newpage
\subsection{Joins}
Joins, dt. \textit{Verbund}, zählen einerseits zu den mächtigsten Werkzeugen von relationalen Datenbank-Management-Systemen, gleichzeitig aber auch, im Bezug zur Ausführung, zu den aufwändigsten. In den folgenden Abschnitten werden kurz alle verschiedenen Arten von Joins kurz beschrieben und anhand eines Beispiels verdeutlicht. Im Kapitel \nameref{sec:algorithms} werden die unterschiedlichen Möglichkeiten erläutert wie Joins auf Datenbank-Ebene implementiert werden können. Tenzing unterstützt alle genannten Join-Typen.

Ein Join kann als ein bedingtes kartesisches Produkt verstanden werden. Dabei wird jeder Tupel aus der linken mit einem Tupel aus der rechten Tabelle kombiniert.  Durch eine Bedingung, bestehend aus Prädikaten, kann das Ergebnis dieser Operation eingeschränkt werden.

\subsubsection{Inner Join}
Bei einem Inner Join werden Tupel nur dann in die Ergebnismenge übernommen wenn alle beteiligten Tupel die entsprechende Bedingung erfüllen. Am konkreten Beispiel in Listing \ref{lst:explicit-inner-join} werden nur die Städte ausgegeben, zu denen es ein konkretes Land im Datenbestand gibt. Der Ergebnis dieses Joins ist in Tabelle \ref{tab:inner-join} zu sehen. Für Inner Joins gibt es zwei unterschiedliche Schreibweisen: eine implizite und eine explizite. Listing \ref{lst:explicit-inner-join} und \ref{lst:implicit-inner-join} zeigen beide Varianten.

\begin{listing}[H]
\begin{minted}{sql}
SELECT city.name, country.name 
FROM City city 
JOIN Country country 
ON city.country_id = country.id;
\end{minted}
\caption{Expliziter Inner Join}
\label{lst:explicit-inner-join}
\end{listing}

\begin{listing}[H]
\begin{minted}{sql}
SELECT city.name, country.name 
FROM City city, Country country 
WHERE city.country_id = country.id;
\end{minted}
\caption{Impliziter Inner Join}
\label{lst:inplicit-inner-join}
\end{listing}

\begin{minipage}{\textwidth}
\begin{minipage}[b]{0.49\textwidth}
\begin{figure}[H]
\centering
\subfigure[]{
  \begin{tabular}{| c | c | c |}
    \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
  \end{tabular}
}
\subfigure[]{
  \begin{tabular}{| c | c |}
    \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
  \end{tabular}
}
\end{figure}
\begin{figure}[H]
\centering
  \begin{tabular}{| c | c | c | c | c |}
    \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
  \end{tabular}
\caption{Schema eines Inner Joins}
\end{figure}
\end{minipage}
\hfill
\begin{minipage}[b]{0.49\textwidth}
\begin{table}[H]
\centering
  \begin{tabular}{| l | l | l | l |}
    \hline
    city.name & country.name\\ \hline
    \hline
   Berlin & Deutschland \\ \hline
   München & Deutschland \\ \hline
   London & United Kingdom \\ \hline
   Paris & France \\ \hline
   Edinburgh & United Kingdom \\ \hline
   New York City & United States \\ \hline
   Los Angeles & United States \\ \hline
   Lyon & France \\ \hline
  \end{tabular}
\caption{Ergebnis eines Inner Joins}
\label{tab:inner-join}
\end{table}
\end{minipage}
\end{minipage}

\subsubsection{Cross Join}
Ein Cross Join ist, wie alle Joins, ein kartesisches Produkt mit der Ausnahme, dass keine Bedingung angewandt wird. Das bedeutet, dass jeder Tupel mit jedem anderen Tupel aus allen anderen beteiligten Tabellen kombiniert wird. Da die Ergebnismenge eines Cross Joins auf den oben vorgestellten Beispieltabellen bereits 45 Tupel enthalten würde, wird an dieser Stelle auf die Darstellung verzichtet.

\subsubsection{Outer Join}
Outer Joins erlauben es, im Gegensatz zum Inner Join, Tupel auch dann in die Ergebnismenge zu übernehmen, wenn nur ein Tupel der beteiligten Tabellen die zugehörige Bedingung erfüllt. Dadurch entstehen drei verschiedene Möglichkeiten: der \texttt{LEFT JOIN}, der \texttt{RIGHT JOIN} und der \texttt{FULL JOIN}.

\subsubsection{Left Outer Join}
Der Left Outer Join, oder auch nur Left Join, existiert im Gegensatz zum Inner Join nur in expliziter Form. Die Ergebnismenge enthält jeden Tupel aus der linken Tabelle mindestens einmal, unabhängig davon ob Tupel in den anderen beteiligten Tabellen existieren die die Bedingung erfüllen oder nicht.

\begin{listing}[H]
\begin{minted}{sql}
SELECT city.name, country.name 
FROM City city
LEFT JOIN Country country 
ON city.country_id = country.id;
\end{minted}
\caption{SQL-Query für einen Left Join}
\label{lst:left-join}
\end{listing}

\begin{minipage}{\textwidth}
\begin{minipage}[b]{0.49\textwidth}
\begin{figure}[H]
\centering
\subfigure[]{
  \begin{tabular}{| c | c | c |}
    \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
  \end{tabular}
}
\subfigure[]{
  \begin{tabular}{| c | c |}
    \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
  \end{tabular}
}
\end{figure}
\begin{figure}[H]
\centering
  \begin{tabular}{| c | c |}
    \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \\ \hline
  \end{tabular}
\caption{Schema eines Left Joins}
\end{figure}
\end{minipage}
\hfill
\begin{minipage}[b]{0.49\textwidth}
\begin{table}[H]
\centering
  \begin{tabular}{| l | l | l | l |}
    \hline
    city.name & country.name\\ \hline
    \hline
   Berlin & Deutschland \\ \hline
   München & Deutschland \\ \hline
   London & United Kingdom \\ \hline
   Paris & France \\ \hline
   Edinburgh & United Kingdom \\ \hline
   New York City & United States \\ \hline
   Los Angeles & United States \\ \hline
   Lyon & France \\ \hline
   Stockholm & NULL \\ \hline
  \end{tabular}
\caption{Ergebnis eines Left Joins}
\label{tab:left-join}
\end{table}
\end{minipage}
\end{minipage}

\newpage
\subsubsection{Right Outer Join}
Der Right Outer Join, oder auch nur Right Join, ist äquivalent zum Left Join mit der Ausnahme, dass Tupel aus der rechten Seite des Verbundes mindestens einmal in der Ergebnismenge auftreten.

\begin{listing}[H]
\begin{minted}{sql}
SELECT city.name, country.name 
FROM City city
RIGHT JOIN Country country 
ON city.country_id = country.id;
\end{minted}
\caption{SQL-Query für einen Right Join}
\label{lst:right-join}
\end{listing}

\begin{minipage}{\textwidth}
\begin{minipage}[b]{0.49\textwidth}
\begin{figure}[H]
\centering
\subfigure[]{
  \begin{tabular}{| c | c | c |}
    \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
  \end{tabular}
}
\subfigure[]{
  \begin{tabular}{| c | c |}
    \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
  \end{tabular}
}
\end{figure}
\begin{figure}[H]
\centering
  \begin{tabular}{| c | c |}
    \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    & \cellcolor{cell-odd} \\ \hline
  \end{tabular}
\caption{Schema eines Right Joins}
\end{figure}
\end{minipage}
\hfill
\begin{minipage}[b]{0.49\textwidth}
\begin{table}[H]
\centering
  \begin{tabular}{| l | l | l | l |}
    \hline
    city.name & country.name\\ \hline
    \hline
   Berlin & Deutschland \\ \hline
   München & Deutschland \\ \hline
   London & United Kingdom \\ \hline
   Paris & France \\ \hline
   Edinburgh & United Kingdom \\ \hline
   New York City & United States \\ \hline
   Los Angeles & United States \\ \hline
   Lyon & France \\ \hline
   NULL & Japan \\ \hline
  \end{tabular}
\caption{Ergebnis eines Right Joins}
\label{tab:right-join}
\end{table}
\end{minipage}
\end{minipage}

\newpage
\subsubsection{Full Outer Join}
Ein Full Outer Join, oder nur Full Join, ist eine Kombination der Eigenschaften eines Left- und eines Right Joins. Bei einem Full Join werden Tupel dann in die Ergebnismenge übernommen, wenn mindestens ein Tupel aller beteiligten Tabellen die zugehörige Bedingung erfüllt.

\begin{listing}[H]
\begin{minted}{sql}
SELECT city.name, country.name 
FROM City city
FULL JOIN Country country 
ON city.country_id = country.id;
\end{minted}
\caption{SQL-Query für einen Full Join}
\label{lst:full-join}
\end{listing}

\begin{minipage}{\textwidth}
\begin{minipage}[b]{0.49\textwidth}
\begin{figure}[H]
\centering
\subfigure[]{
  \begin{tabular}{| c | c | c |}
    \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
  \end{tabular}
}
\subfigure[]{
  \begin{tabular}{| c | c |}
    \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
  \end{tabular}
}
\end{figure}
\begin{figure}[H]
\centering
  \begin{tabular}{| c | c |}
    \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \\ \hline
    & \cellcolor{cell-odd} \\ \hline
  \end{tabular}
\caption{Schema eines Full Joins}
\end{figure}
\end{minipage}
\hfill
\begin{minipage}[b]{0.49\textwidth}
\begin{table}[H]
\centering
  \begin{tabular}{| l | l | l | l |}
    \hline
    city.name & country.name\\ \hline
    \hline
   Berlin & Deutschland \\ \hline
   München & Deutschland \\ \hline
   London & United Kingdom \\ \hline
   Paris & France \\ \hline
   Edinburgh & United Kingdom \\ \hline
   New York City & United States \\ \hline
   Los Angeles & United States \\ \hline
   Lyon & France \\ \hline
   Stockholm & NULL \\ \hline
   NULL & Japan \\ \hline
  \end{tabular}
\caption{Ergebnis eines Full Joins}
\label{tab:full-join}
\end{table}
\end{minipage}
\end{minipage}

\newpage
\subsubsection{Self Join}
Ein Self Join ist kein eigener Join-Typ in engeren Sinne; er beschreibt lediglich einen Join bei dem eine Tabelle mit sich selbst gejoint wird.

\begin{listing}[H]
\begin{minted}{sql}
SELECT a.name, b.name 
FROM City a
LEFT JOIN City b
ON a.country_id = b.country_id AND a.id <> b.id;
\end{minted}
\caption{SQL-Query für einen Self Join}
\label{lst:self-join}
\end{listing}

Der in Listing \ref{lst:self-join} definierte Self Join auf der Tabelle \texttt{City} liefert als Ergebnis Paare Städten die im gleichen Land liegen. Das Ergebnis dieser Abfrage ist in Tabelle \ref{tab:self-join} zu sehen.

\begin{minipage}{\textwidth}
\begin{minipage}[b]{0.49\textwidth}
\begin{figure}[H]
\centering
\subfigure[]{
  \begin{tabular}{| c | c | c |}
    \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
  \end{tabular}
}
\subfigure[]{
  \begin{tabular}{| c | c |}
    \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
  \end{tabular}
}
\end{figure}
\begin{figure}[H]
\centering
  \begin{tabular}{| c | c |}
    \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell} & \\ \hline
  \end{tabular}
\caption{Schema eines Self Joins}
\end{figure}
\end{minipage}
\hfill
\begin{minipage}[b]{0.49\textwidth}
\begin{table}[H]
\centering
  \begin{tabular}{| l | l | l | l |}
    \hline
    a.name & b.name\\ \hline
    \hline
    Berlin & München \\ \hline
    München & Berlin \\ \hline
    London & Edinburgh \\ \hline
    Paris & Lyon \\ \hline
    Edinburgh & London \\ \hline
    New York City & Los Angeles \\ \hline
    Los Angeles & New York City \\ \hline
    Lyon & Paris \\ \hline
    Stockholm & NULL \\ \hline
  \end{tabular}
\caption{Ergebnis eines Self Joins}
\label{tab:self-join}
\end{table}
\end{minipage}
\end{minipage}

\newpage
\subsubsection{Equi-Join}
Ein Equi-Join ist, ähnlich des Self Joins, kein eigener Join-Typ im klassischen Sinne. Ein Join wird dann als Equi-Join bezeichnet wenn die Join-Bedingung als Operator ausschließlich die Gleichheit \texttt{=}, engl. equality, verwendet.

\begin{listing}[H]
\begin{minted}{sql}
SELECT city.name, country.name 
FROM City city
JOIN Country country 
ON city.id = country.id;
\end{minted}
\caption{SQL-Query für einen Equi-Join}
\label{lst:equi-join}
\end{listing}

Für den Sonderfall dass beide Spalten den gleichen Namen haben kann nach SQL/92-Standard das Schlüsselwort \texttt{USING} verwendet werden.

\begin{listing}[H]
\begin{minted}{sql}
SELECT city.name, country.name 
FROM City city
JOIN Country country 
USING (id);
\end{minted}
\caption{SQL-Query für einen Equi-Join mit dem Schlüsselwort \texttt{USING}}
\label{lst:equi-join-using}
\end{listing}

\subsubsection{Natural Join}
Natural Joins sind sehr eng mit Equi-Joins verwandt. Bei einem Natural Join werden alle Spalten der beteiligten Tabellen für die Join-Bedingung genutzt wenn sie den gleichen Namen haben.

\begin{listing}[H]
\begin{minted}{sql}
SELECT city.name, country.name 
FROM City city
NATURAL JOIN Country country;
\end{minted}
\caption{SQL-Query für einen Natural Join}
\label{lst:natural-join}
\end{listing}

\newpage
\subsubsection{Semi-Join}
Semi- und Anti-Joins haben eine Besonderheit die sie von allen anderen Join-Arten unterscheiden. Im eigentlichen SQL-Query kommt in keiner Weise das Schlüsselwort \texttt{JOIN} vor. Stattdessen wird im Falle des Semi-Joins ein Sub-Query mit dem Schlüsselwort \texttt{EXISTS} verwendet. Alternativ wäre auch ein Sub-Query mit \texttt{IN} möglich. SQL-Engines verarbeiten diese Queries sehr ähnlich zu normalen Joins. Der Vorteil für den Aufrufer ist, dass Tupel aus der linken Tabelle maximal einmal auftreten, unabhängig davon wieviele Treffer das Sub-Query liefert. Bei einem normalen Join würde die Anzahl der Treffer auf der rechten Seite bestimmen wie oft Treffer auf der linken Seite ausgegeben werden. Semi-Joins sind in der Regel eine performante Alternative zu \texttt{DISTINCT} und \texttt{GROUP BY}.

\begin{listing}[H]
\begin{minted}{sql}
SELECT *
FROM Country country
WHERE EXISTS (SELECT * FROM City city WHERE city.country_id = country.id);
\end{minted}
\caption{SQL-Query für einen Semi-Join}
\label{lst:semi-join}
\end{listing}

\begin{table}[H]
\centering
  \begin{tabular}{| l | l | l |}
    \hline
    id & name & country\protect{\textunderscore}code \\ \hline
    \hline
    1 & Deutschland & DE \\ \hline
    2 & United Kingdom & UK \\ \hline
    3 & France & FR \\ \hline
    4 & United States & US \\ \hline
  \end{tabular}
\end{table}

\subsubsection{Anti-Join}
Anti-Joins sind wie negierte Semi-Joins. Statt der Schlüsselwörter \texttt{EXISTS} und \texttt{IN} werden \texttt{NOT EXISTS} bzw. \texttt{NOT IN} verwendet. Der Name \textit{Anti}-Join rührt daher, dass klassische Joins dazu benutzt werden, um Zusammenhänge und Übereinstimmungen zu finden respektive auszunutzen. Anti-Joins hingegen sind der präferierte Weg wenn die Anforderung verlangt, dass Tupel in der linken Tabelle keine Treffer in der rechten haben.

\begin{listing}[H]
\begin{minted}{sql}
SELECT country.name
FROM Country country
WHERE NOT EXISTS (SELECT * FROM City city WHERE city.country_id = country.id);
\end{minted}
\caption{SQL-Query für einen Anti-Join}
\label{lst:anti-join}
\end{listing}

\begin{table}[H]
\centering
  \begin{tabular}{| l | l | l |}
    \hline
    id & name & country\protect{\textunderscore}code \\ \hline
    \hline
    5 & Japan & JP \\ \hline
  \end{tabular}
\end{table}

\newpage

\subsection{Join-Algorithmen}
\label{sec:algorithms}

In aktuellen relationalen Datenbanken gibt es verschiedene Algorithmen um Joins algorithmisch umzusetzen. Einige dieser Algorithmen sind für bestimmte Arten von Joins besser geeignet als andere. Zu den Faktoren, die eine Rolle bei der Auswahl des besten Algorithmus für eine konkrete Abfrage spielen, zählen unter anderem die Größe der involvierten Relationen/Tabellen sowie die Art der Join-Bedingung.

\subsubsection{Nested-Loop-Join}
\label{sec:nested-loop}
Nested-Loop-Joins sind die einfachste Art der Bildung von Joins. Zwei geschachtelten Schleifen laufen sowohl über die linke als auch die rechte Relation. Für jedes Tupel-Paar das so gebildet wird entscheidet die Join-Bedingung ob es ein Treffer ist oder nicht. Listing \ref{lst:nested-loop} zeigt den schematischen Ansatz anhand eines kurzen Quellcode-Ausschnitts. Die Funktion \texttt{emit} soll exemplarisch dazu dienen den gefunden Treffer auszugeben.

Der Vorteil des Nested-Loop-Join-Algorithmus ist, dass er für jede Art von Join anwendbar ist. Zusätzlich kann er erweitert werden, für den Fall, dass ein Join mehr als zwei Relationen beinhaltet. Der negative Aspekt dieses Algorithmus ist sein Rechenaufwand. Schon bei zwei Relationen muss für jeden Tupel der linken Seite ein kompletter Tablescan der rechten Seite ausgeführt werden. Die Anzahl der Schleifendurchläufe errechnet sich aus dem Produkt der Größen der beiden Tabellen.

\begin{listing}[H]
\begin{minted}{javascript}
for (var left in leftTable) {
    for (var right in rightTable) {
        if (predicate(left, right)) {
            emit(left, right);
        }
    }
}
\end{minted}
\caption{Nested-Loop-Join}
\label{lst:nested-loop}
\end{listing}

\subsubsection{Block-Nested-Loop-Join}
Der Block-Nested-Loop-Join-Algorithmus ist eine Verbesserung des \nameref{lst:nested-loop}-Algorithmus. Der Ansatz ist, nicht für jeden Tupel aus der linken Tabelle einen kompletten Tablescan der rechten Tabelle ausführen zu müssen, sondern Blöcke zu bilden. Dadurch wird nur noch blockweise durch die Tabelle gelaufen. Dadurch ergibt sich, bedingt durch weniger wahlfreie Zugriffe und mehr sequentielle Leseoperationen auf der Festplatte, eine höhere Ausführgeschwindigkeit. Alle sonstigen Vorteile des Nested-Loop-Join-Algorithmus gelten in gleicher weise für die blockweise Variante.

\begin{listing}[H]
\begin{minted}{javascript}
for (var leftBLock in leftTable) {
    for (var rightBlock in rightTable) {
        for (var left in leftBlock)  {
            for (var right in rightBlock) {
                if (predicate(left, right)) {
                    emit(left, right);
                }
            }
        }
    }
}
\end{minted}
\caption{Block-Nested-Loop-Join}
\label{lst:block-nested-loop}
\end{listing}

\newpage
\subsubsection{Sort/Merge-Join}
sort on join attribute, merge, stack pointer, compare, uses indices
natural, equi

\begin{figure}[H]
\centering
\subfigure[]{
  \begin{tabular}{| c | c | c | c | c |}
    \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \noalign{\smash{\llap{\lower2pt\hbox{\tt $\longrightarrow$}}}}
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
    \cellcolor{cell} \\ \hline
  \end{tabular}
}
\hspace*{1cm}
\subfigure[]{
  \begin{tabular}{| c | c | c | c | c |}
    \hline
    \cellcolor{cell-odd} \\ \hline
    \noalign{\smash{\llap{\lower2pt\hbox{\tt $\longrightarrow$}}}}
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
    \cellcolor{cell-odd} \\ \hline
  \end{tabular}
}
\caption{Schematische Darstellung des Sort/Merge-Join-Algorithmus}
\end{figure}

\subsubsection{Hash-Join}
hashtable on left, loop right, non empty bucket -> hit
equality operator

\newpage

\section{MapReduce}
\label{mapreduce}

\subsection{Definition}

\begin{quote}
MapReduce is a programming model and an associated implementation for processing and generating large data sets. \cite{MAPREDUCE}
\end{quote}

\begin{quote}
MapReduce is a software framework introduced by Google in 2004 to support distributed computing on large data sets on clusters of computers. \cite{WP-MAPREDUCE}
\end{quote}

\begin{quote}
Hadoop MapReduce is a software framework for easily writing applications which process vast amounts of data (multi-terabyte data-sets) in-parallel on large clusters (thousands of nodes) of commodity hardware in a reliable, fault-tolerant manner. \cite{HADOOP}
\end{quote}

\subsection{Motivation}

\subsection{Funktionsweise}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{mapreduce.png}
\caption{Die zwei Phasen eines MapReduce-Jobs \protect\cite{GARFINKEL}}
\end{figure}

\subsection{Open Source}
Googles Implementierung des MapReduce-Frameworks ist nicht öffentlich verfügbar. Die Apache Software Foundation hat sich mit dem Hadoop-Projekt zum Ziel gesetzt ein freies MapReduce-Ecosystem zu entwickeln.

\newpage

\nocite{GFS}
\nocite{GOOGLE-TENZING}
\nocite{GOOGLE-MAPREDUCE}
\nocite{GOOGLE-GFS}
\nocite{KemperEickler}
\nocite{KandziaKlein}
\nocite{Codd}
\nocite{Selinger}
\nocite{Zeller}
\nocite{Ioannidis}
\addcontentsline{toc}{section}{Literatur}
\printbibliography

\newpage

\addcontentsline{toc}{section}{Abbildungsverzeichnis}
\listoffigures

\addcontentsline{toc}{section}{Tabellenverzeichnis}
\listoftables

\addcontentsline{toc}{section}{Quellcodeverzeichnis}
\renewcommand\listoflistingscaption{Quellcodeverzeichnis}
\listoflistings

\end{document}

